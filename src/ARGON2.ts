'use strict'

// from https://github.com/urbit/argon2-wasm

// base64
// copied from https://github.com/beatgammit/base64-js

const lookup: string[] = [];
const revLookup: number[] = [];
const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63


function getLens(b64: string) {
    var len = b64.length

    if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=')
    if (validLen === -1) validLen = len

    var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)

    return [validLen, placeHoldersLen]
}

function _byteLength(b64: string, validLen: number, placeHoldersLen: number) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray(b64: string) {
    var tmp
    var lens = getLens(b64)
    var validLen = lens[0]
    var placeHoldersLen = lens[1]

    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

    var curByte = 0

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen

    for (var i = 0; i < len; i += 4) {
        tmp =
            (revLookup[b64.charCodeAt(i)] << 18) |
            (revLookup[b64.charCodeAt(i + 1)] << 12) |
            (revLookup[b64.charCodeAt(i + 2)] << 6) |
            revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
    }

    if (placeHoldersLen === 2) {
        tmp =
            (revLookup[b64.charCodeAt(i)] << 2) |
            (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
    }

    if (placeHoldersLen === 1) {
        tmp =
            (revLookup[b64.charCodeAt(i)] << 10) |
            (revLookup[b64.charCodeAt(i + 1)] << 4) |
            (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
    }

    return arr
}

function tripletToBase64(num: number) {
    return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
}

function encodeChunk(uint8: Uint8Array, start: number, end: number) {
    var tmp
    var output = []
    for (var i = start; i < end; i += 3) {
        tmp =
            ((uint8[i] << 16) & 0xFF0000) +
            ((uint8[i + 1] << 8) & 0xFF00) +
            (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
    }
    return output.join('')
}

function fromByteArray(uint8: Uint8Array) {
    var tmp
    var len = uint8.length
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    var parts = []
    var maxChunkLength = 16383 // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(
            uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
        ))
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
            lookup[tmp >> 2] +
            lookup[(tmp << 4) & 0x3F] +
            '=='
        )
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
            lookup[tmp >> 10] +
            lookup[(tmp >> 4) & 0x3F] +
            lookup[(tmp << 2) & 0x3F] +
            '='
        )
    }

    return parts.join('')
}

const loadModule = (function () {
    //@ts-ignore
    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
    return (
        function (Module: any) {
            Module = Module || {};

            var Module = typeof Module !== "undefined" ? Module : {};
            Module["wasmBinary"] = toByteArray("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AAAACgAAAAUAAAAKAAAAAgAAAAgAAAAEAAAABwAAAAYAAAABAAAABQAAAA8AAAALAAAACQAAAA4AAAADAAAADAAAAA0AQcQNC5sJAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAADgAAAAoAAAAEAAAACAAAAAkAAAAPAAAADQAAAAYAAAABAAAADAAAAAAAAAACAAAACwAAAAcAAAAFAAAAAwAAAGFyZ29uMmQAQXJnb24yZABhcmdvbjJpAEFyZ29uMmkAYXJnb24yaWQAQXJnb24yaWQAYXJnb24ydQBBcmdvbjJ1AFVua25vd24gZXJyb3IgY29kZQBUaGUgcGFzc3dvcmQgZG9lcyBub3QgbWF0Y2ggdGhlIHN1cHBsaWVkIGhhc2gAU29tZSBvZiBlbmNvZGVkIHBhcmFtZXRlcnMgYXJlIHRvbyBsb25nIG9yIHRvbyBzaG9ydABUaHJlYWRpbmcgZmFpbHVyZQBEZWNvZGluZyBmYWlsZWQARW5jb2RpbmcgZmFpbGVkAE1pc3NpbmcgYXJndW1lbnRzAFRvbyBtYW55IHRocmVhZHMATm90IGVub3VnaCB0aHJlYWRzAE91dHB1dCBwb2ludGVyIG1pc21hdGNoAFRoZXJlIGlzIG5vIHN1Y2ggdmVyc2lvbiBvZiBBcmdvbjIAQXJnb24yX0NvbnRleHQgY29udGV4dCBpcyBOVUxMAFRoZSBhbGxvY2F0ZSBtZW1vcnkgY2FsbGJhY2sgaXMgTlVMTABUaGUgZnJlZSBtZW1vcnkgY2FsbGJhY2sgaXMgTlVMTABNZW1vcnkgYWxsb2NhdGlvbiBlcnJvcgBBc3NvY2lhdGVkIGRhdGEgcG9pbnRlciBpcyBOVUxMLCBidXQgYWQgbGVuZ3RoIGlzIG5vdCAwAFNlY3JldCBwb2ludGVyIGlzIE5VTEwsIGJ1dCBzZWNyZXQgbGVuZ3RoIGlzIG5vdCAwAFNhbHQgcG9pbnRlciBpcyBOVUxMLCBidXQgc2FsdCBsZW5ndGggaXMgbm90IDAAUGFzc3dvcmQgcG9pbnRlciBpcyBOVUxMLCBidXQgcGFzc3dvcmQgbGVuZ3RoIGlzIG5vdCAwAFRvbyBtYW55IGxhbmVzAFRvbyBmZXcgbGFuZXMATWVtb3J5IGNvc3QgaXMgdG9vIGxhcmdlAE1lbW9yeSBjb3N0IGlzIHRvbyBzbWFsbABUaW1lIGNvc3QgaXMgdG9vIGxhcmdlAFRpbWUgY29zdCBpcyB0b28gc21hbGwAU2VjcmV0IGlzIHRvbyBsb25nAFNlY3JldCBpcyB0b28gc2hvcnQAQXNzb2NpYXRlZCBkYXRhIGlzIHRvbyBsb25nAEFzc29jaWF0ZWQgZGF0YSBpcyB0b28gc2hvcnQAU2FsdCBpcyB0b28gbG9uZwBTYWx0IGlzIHRvbyBzaG9ydABQYXNzd29yZCBpcyB0b28gbG9uZwBQYXNzd29yZCBpcyB0b28gc2hvcnQAT3V0cHV0IGlzIHRvbyBsb25nAE91dHB1dCBpcyB0b28gc2hvcnQAT3V0cHV0IHBvaW50ZXIgaXMgTlVMTABPSwAwMTIzNDU2Nzg5");
            var moduleOverrides = {};
            var key;
            for (key in Module) {
                if (Module.hasOwnProperty(key)) {
                    //@ts-ignore
                    moduleOverrides[key] = Module[key]
                }
            }
            Module["arguments"] = [];
            Module["thisProgram"] = "./this.program";
            Module["quit"] = (function (status: number, toThrow: string) {
                throw toThrow
            });
            Module["preRun"] = [];
            Module["postRun"] = [];
            var ENVIRONMENT_IS_WEB = false;
            var ENVIRONMENT_IS_WORKER = false;
            var ENVIRONMENT_IS_NODE = false;
            var ENVIRONMENT_IS_SHELL = false;
            ENVIRONMENT_IS_WEB = typeof window === "object";
            ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
            ENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
            ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
            if (Module["ENVIRONMENT"]) {
                throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)")
            }
            assert(typeof Module["memoryInitializerPrefixURL"] === "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
            assert(typeof Module["pthreadMainPrefixURL"] === "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
            assert(typeof Module["cdInitializerPrefixURL"] === "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
            assert(typeof Module["filePackagePrefixURL"] === "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
            var scriptDirectory = "";

            function locateFile(path: string) {
                if (Module["locateFile"]) {
                    return Module["locateFile"](path, scriptDirectory)
                } else {
                    return scriptDirectory + path
                }
            }
            if (ENVIRONMENT_IS_NODE) {
                scriptDirectory = __dirname + "/";
                var nodeFS: any;
                var nodePath: string;
                Module["read"] = function shell_read(filename: string, binary: boolean) {
                    var ret;
                    if (!nodeFS) nodeFS = require("fs");
                    if (!nodePath) nodePath = require("path");
                    filename = nodePath["normalize"](filename);
                    ret = nodeFS["readFileSync"](filename);
                    return binary ? ret : ret.toString()
                };
                Module["readBinary"] = function readBinary(filename: string) {
                    var ret = Module["read"](filename, true);
                    if (!ret.buffer) {
                        ret = new Uint8Array(ret)
                    }
                    assert(ret.buffer);
                    return ret
                };
                if (process["argv"].length > 1) {
                    Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/")
                }
                Module["arguments"] = process["argv"].slice(2);
                process["on"]("uncaughtException", (function (ex) {
                    if (!(ex instanceof ExitStatus)) {
                        throw ex
                    }
                }));
                process["on"]("unhandledRejection", (function (reason, p) {
                    err("node.js exiting due to unhandled promise rejection");
                    process["exit"](1)
                }));
                Module["quit"] = (function (status: number) {
                    process["exit"](status)
                });
                Module["inspect"] = (function () {
                    return "[Emscripten Module object]"
                })
            } else if (ENVIRONMENT_IS_SHELL) {
                // @ts-ignore
                if (typeof read != "undefined") {
                    // @ts-ignore
                    Module["read"] = function shell_read(f) {
                        // @ts-ignore
                        return read(f)
                    }
                }
                Module["readBinary"] = function readBinary(f: String) {
                    var data;
                    // @ts-ignore
                    if (typeof readbuffer === "function") {
                        // @ts-ignore
                        return new Uint8Array(readbuffer(f))
                    }
                    // @ts-ignore
                    data = read(f, "binary");
                    assert(typeof data === "object");
                    return data
                };
                // @ts-ignore
                if (typeof scriptArgs != "undefined") {
                    // @ts-ignore
                    Module["arguments"] = scriptArgs
                    // @ts-ignore
                } else if (typeof arguments != "undefined") {
                    // @ts-ignore
                    Module["arguments"] = arguments
                }
                // @ts-ignore
                if (typeof quit === "function") {
                    // @ts-ignore
                    Module["quit"] = (function (status) {
                        // @ts-ignore
                        quit(status)
                    })
                }
            } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
                if (ENVIRONMENT_IS_WEB) {
                    if (document.currentScript) {
                        // @ts-ignore
                        scriptDirectory = document.currentScript.src
                    }
                } else {
                    scriptDirectory = self.location.href
                }
                // @ts-ignore
                if (_scriptDir) {
                    // @ts-ignore
                    scriptDirectory = _scriptDir
                }
                if (scriptDirectory.indexOf("blob:") !== 0) {
                    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1)
                } else {
                    scriptDirectory = ""
                }
                Module["read"] = function shell_read(url: string) {
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", url, false);
                    xhr.send(null);
                    return xhr.responseText
                };
                if (ENVIRONMENT_IS_WORKER) {
                    Module["readBinary"] = function readBinary(url: string) {
                        var xhr = new XMLHttpRequest;
                        xhr.open("GET", url, false);
                        xhr.responseType = "arraybuffer";
                        xhr.send(null);
                        return new Uint8Array(xhr.response)
                    }
                }
                Module["readAsync"] = function readAsync(url: string, onload: Function, onerror: ((this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any) | null) {
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", url, true);
                    xhr.responseType = "arraybuffer";
                    xhr.onload = function xhr_onload() {
                        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                            onload(xhr.response);
                            return
                        }
                        // @ts-ignore
                        onerror()
                    };
                    xhr.onerror = onerror;
                    xhr.send(null)
                };
                Module["setWindowTitle"] = (function (title: string) {
                    document.title = title
                })
            } else {
                throw new Error("environment detection error")
            }
            var out = Module["print"] || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null);
            // @ts-ignore
            var err = Module["printErr"] || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || out);
            for (key in moduleOverrides) {
                if (moduleOverrides.hasOwnProperty(key)) {
                    // @ts-ignore
                    Module[key] = moduleOverrides[key]
                }
            }
            // @ts-ignore
            moduleOverrides = undefined;
            var STACK_ALIGN = 16;
            stackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = (function () {
                abort("cannot use the stack before compiled code is ready to run, and has provided stack access")
            });

            function staticAlloc(size: number) {
                assert(!staticSealed);
                var ret = STATICTOP;
                STATICTOP = STATICTOP + size + 15 & -16;
                assert(STATICTOP < TOTAL_MEMORY, "not enough memory for static allocation - increase TOTAL_MEMORY");
                return ret
            }

            function dynamicAlloc(size: number) {
                assert(DYNAMICTOP_PTR);
                var ret = HEAP32[DYNAMICTOP_PTR >> 2];
                var end = ret + size + 15 & -16;
                HEAP32[DYNAMICTOP_PTR >> 2] = end;
                if (end >= TOTAL_MEMORY) {
                    var success = enlargeMemory();
                    // @ts-ignore
                    if (!success) {
                        HEAP32[DYNAMICTOP_PTR >> 2] = ret;
                        return 0
                    }
                }
                return ret
            }

            function alignMemory(size: number, factor?: number) {
                if (!factor) factor = STACK_ALIGN;
                var ret = size = Math.ceil(size / factor) * factor;
                return ret
            }

            function getNativeTypeSize(type: string) {
                switch (type) {
                    case "i1":
                    case "i8":
                        return 1;
                    case "i16":
                        return 2;
                    case "i32":
                        return 4;
                    case "i64":
                        return 8;
                    case "float":
                        return 4;
                    case "double":
                        return 8;
                    default: {
                        if (type[type.length - 1] === "*") {
                            return 4
                        } else if (type[0] === "i") {
                            var bits = parseInt(type.substr(1));
                            assert(bits % 8 === 0);
                            return bits / 8
                        } else {
                            return 0
                        }
                    }
                }
            }

            function warnOnce(text: string) {
                // @ts-ignore
                if (!warnOnce.shown) warnOnce.shown = {};
                // @ts-ignore
                if (!warnOnce.shown[text]) {
                    // @ts-ignore
                    warnOnce.shown[text] = 1;
                    err(text)
                }
            }
            var asm2wasmImports = {
                "f64-rem": (function (x: number, y: number) {
                    return x % y
                }),
                "debugger": (function () {
                    debugger
                })
            };
            var functionPointers = new Array(0);
            var GLOBAL_BASE = 1024;
            var ABORT = false;
            var EXITSTATUS = 0;

            function assert(condition: any, text?: string) {
                if (!condition) {
                    abort("Assertion failed: " + text)
                }
            }

            function setValue(ptr: number, value: number, type: string, noSafe?: any) {
                type = type || "i8";
                if (type.charAt(type.length - 1) === "*") type = "i32";
                switch (type) {
                    case "i1":
                        HEAP8[ptr >> 0] = value;
                        break;
                    case "i8":
                        HEAP8[ptr >> 0] = value;
                        break;
                    case "i16":
                        HEAP16[ptr >> 1] = value;
                        break;
                    case "i32":
                        HEAP32[ptr >> 2] = value;
                        break;
                    case "i64":
                        // @ts-ignore
                        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
                        break;
                    case "float":
                        HEAPF32[ptr >> 2] = value;
                        break;
                    case "double":
                        HEAPF64[ptr >> 3] = value;
                        break;
                    default:
                        abort("invalid type for setValue: " + type)
                }
            }
            var ALLOC_NORMAL = 0;
            var ALLOC_STATIC = 2;
            var ALLOC_NONE = 4;

            function allocate(slab: Uint8Array, types: string, allocator: number, ptr: number) {
                var zeroinit, size;
                if (typeof slab === "number") {
                    zeroinit = true;
                    size = slab
                } else {
                    zeroinit = false;
                    size = slab.length
                }
                var singleType = typeof types === "string" ? types : null;
                var ret;
                if (allocator == ALLOC_NONE) {
                    ret = ptr
                } else {
                    ret = [typeof _malloc === "function" ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length))
                }
                if (zeroinit) {
                    var stop;
                    ptr = ret;
                    assert((ret & 3) == 0);
                    stop = ret + (size & ~3);
                    for (; ptr < stop; ptr += 4) {
                        HEAP32[ptr >> 2] = 0
                    }
                    stop = ret + size;
                    while (ptr < stop) {
                        HEAP8[ptr++ >> 0] = 0
                    }
                    return ret
                }
                if (singleType === "i8") {
                    // @ts-ignore
                    if (slab.subarray || slab.slice) {
                        HEAPU8.set(slab, ret)
                    } else {
                        HEAPU8.set(new Uint8Array(slab), ret)
                    }
                    return ret
                }
                var i = 0,
                    type, typeSize: number, previousType;
                while (i < size) {
                    var curr = slab[i];
                    type = singleType || types[i];
                    // @ts-ignore
                    if (type === 0) {
                        i++;
                        continue
                    }
                    assert(type, "Must know what type to store in allocate!");
                    if (type == "i64") type = "i32";
                    setValue(ret + i, curr, type);
                    if (previousType !== type) {
                        typeSize = getNativeTypeSize(type);
                        previousType = type
                    }
                    // @ts-ignore
                    i += typeSize
                }
                return ret
            }

            function Pointer_stringify(ptr: number, length: number) {
                if (length === 0 || !ptr) return "";
                var hasUtf = 0;
                var t;
                var i = 0;
                while (1) {
                    assert(ptr + i < TOTAL_MEMORY);
                    t = HEAPU8[ptr + i >> 0];
                    hasUtf |= t;
                    if (t == 0 && !length) break;
                    i++;
                    if (length && i == length) break
                }
                if (!length) length = i;
                var ret = "";
                if (hasUtf < 128) {
                    var MAX_CHUNK = 1024;
                    var curr;
                    while (length > 0) {
                        // @ts-ignore
                        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
                        ret = ret ? ret + curr : curr;
                        ptr += MAX_CHUNK;
                        length -= MAX_CHUNK
                    }
                    return ret
                }
                return UTF8ToString(ptr)
            }
            var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

            // @ts-ignore
            function UTF8ArrayToString(u8Array: Uint8Array, idx: number) {
                var endPtr = idx;
                while (u8Array[endPtr]) ++endPtr;
                if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
                    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))
                } else {
                    var u0, u1, u2, u3, u4, u5;
                    var str = "";
                    while (1) {
                        u0 = u8Array[idx++];
                        if (!u0) return str;
                        if (!(u0 & 128)) {
                            str += String.fromCharCode(u0);
                            continue
                        }
                        u1 = u8Array[idx++] & 63;
                        if ((u0 & 224) == 192) {
                            str += String.fromCharCode((u0 & 31) << 6 | u1);
                            continue
                        }
                        u2 = u8Array[idx++] & 63;
                        if ((u0 & 240) == 224) {
                            u0 = (u0 & 15) << 12 | u1 << 6 | u2
                        } else {
                            u3 = u8Array[idx++] & 63;
                            if ((u0 & 248) == 240) {
                                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3
                            } else {
                                u4 = u8Array[idx++] & 63;
                                if ((u0 & 252) == 248) {
                                    u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4
                                } else {
                                    u5 = u8Array[idx++] & 63;
                                    u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5
                                }
                            }
                        }
                        if (u0 < 65536) {
                            str += String.fromCharCode(u0)
                        } else {
                            var ch = u0 - 65536;
                            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
                        }
                    }
                }
            }

            function UTF8ToString(ptr: number) {
                return UTF8ArrayToString(HEAPU8, ptr)
            }

            function stringToUTF8Array(str: string, outU8Array: Uint8Array, outIdx: number, maxBytesToWrite: number) {
                if (!(maxBytesToWrite > 0)) return 0;
                var startIdx = outIdx;
                var endIdx = outIdx + maxBytesToWrite - 1;
                for (var i = 0; i < str.length; ++i) {
                    var u = str.charCodeAt(i);
                    if (u >= 55296 && u <= 57343) {
                        var u1 = str.charCodeAt(++i);
                        u = 65536 + ((u & 1023) << 10) | u1 & 1023
                    }
                    if (u <= 127) {
                        if (outIdx >= endIdx) break;
                        outU8Array[outIdx++] = u
                    } else if (u <= 2047) {
                        if (outIdx + 1 >= endIdx) break;
                        outU8Array[outIdx++] = 192 | u >> 6;
                        outU8Array[outIdx++] = 128 | u & 63
                    } else if (u <= 65535) {
                        if (outIdx + 2 >= endIdx) break;
                        outU8Array[outIdx++] = 224 | u >> 12;
                        outU8Array[outIdx++] = 128 | u >> 6 & 63;
                        outU8Array[outIdx++] = 128 | u & 63
                    } else if (u <= 2097151) {
                        if (outIdx + 3 >= endIdx) break;
                        outU8Array[outIdx++] = 240 | u >> 18;
                        outU8Array[outIdx++] = 128 | u >> 12 & 63;
                        outU8Array[outIdx++] = 128 | u >> 6 & 63;
                        outU8Array[outIdx++] = 128 | u & 63
                    } else if (u <= 67108863) {
                        if (outIdx + 4 >= endIdx) break;
                        outU8Array[outIdx++] = 248 | u >> 24;
                        outU8Array[outIdx++] = 128 | u >> 18 & 63;
                        outU8Array[outIdx++] = 128 | u >> 12 & 63;
                        outU8Array[outIdx++] = 128 | u >> 6 & 63;
                        outU8Array[outIdx++] = 128 | u & 63
                    } else {
                        if (outIdx + 5 >= endIdx) break;
                        outU8Array[outIdx++] = 252 | u >> 30;
                        outU8Array[outIdx++] = 128 | u >> 24 & 63;
                        outU8Array[outIdx++] = 128 | u >> 18 & 63;
                        outU8Array[outIdx++] = 128 | u >> 12 & 63;
                        outU8Array[outIdx++] = 128 | u >> 6 & 63;
                        outU8Array[outIdx++] = 128 | u & 63
                    }
                }
                outU8Array[outIdx] = 0;
                return outIdx - startIdx
            }

            function lengthBytesUTF8(str: string) {
                var len = 0;
                for (var i = 0; i < str.length; ++i) {
                    var u = str.charCodeAt(i);
                    if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
                    if (u <= 127) {
                        ++len
                    } else if (u <= 2047) {
                        len += 2
                    } else if (u <= 65535) {
                        len += 3
                    } else if (u <= 2097151) {
                        len += 4
                    } else if (u <= 67108863) {
                        len += 5
                    } else {
                        len += 6
                    }
                }
                return len
            }
            var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;

            function demangle(func: Function) {
                warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");
                return func
            }

            function demangleAll(text: string) {
                var regex = /__Z[\w\d_]+/g;
                return text.replace(regex, (function (x) {
                    // @ts-ignore
                    var y = demangle(x);
                    // @ts-ignore
                    return x === y ? x : x + " [" + y + "]"
                }))
            }

            function jsStackTrace() {
                var err = new Error;
                if (!err.stack) {
                    try {
                        // @ts-ignore
                        throw new Error(0)
                    } catch (e) {
                        // @ts-ignore
                        err = e
                    }
                    if (!err.stack) {
                        return "(no stack trace available)"
                    }
                }
                return err.stack.toString()
            }

            function stackTrace() {
                var js = jsStackTrace();
                if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"]();
                return demangleAll(js)
            }
            var WASM_PAGE_SIZE = 65536;
            var ASMJS_PAGE_SIZE = 16777216;

            function alignUp(x: number, multiple: number) {
                if (x % multiple > 0) {
                    x += multiple - x % multiple
                }
                return x
            }
            var buffer: ArrayBuffer, HEAP8: Int8Array, HEAPU8: Uint8Array, HEAP16: Int16Array, HEAPU16: Uint16Array, HEAP32: Int32Array, HEAPU32: Uint32Array, HEAPF32: Float32Array, HEAPF64: Float64Array;

            function updateGlobalBuffer(buf: ArrayBuffer) {
                Module["buffer"] = buffer = buf
            }

            function updateGlobalBufferViews() {
                Module["HEAP8"] = HEAP8 = new Int8Array(buffer);
                Module["HEAP16"] = HEAP16 = new Int16Array(buffer);
                Module["HEAP32"] = HEAP32 = new Int32Array(buffer);
                Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);
                Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);
                Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);
                Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);
                Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer)
            }
            var STATIC_BASE: number, STATICTOP: number, staticSealed: boolean;
            var STACK_BASE: number, STACKTOP: number, STACK_MAX: number;
            var DYNAMIC_BASE: number, DYNAMICTOP_PTR: number;
            STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
            staticSealed = false;

            function writeStackCookie() {
                assert((STACK_MAX & 3) == 0);
                HEAPU32[(STACK_MAX >> 2) - 1] = 34821223;
                HEAPU32[(STACK_MAX >> 2) - 2] = 2310721022
            }

            function checkStackCookie() {
                if (HEAPU32[(STACK_MAX >> 2) - 1] != 34821223 || HEAPU32[(STACK_MAX >> 2) - 2] != 2310721022) {
                    abort("Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x" + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + " " + HEAPU32[(STACK_MAX >> 2) - 1].toString(16))
                }
                if (HEAP32[0] !== 1668509029) throw "Runtime error: The application has corrupted its heap memory area (address zero)!"
            }

            function abortStackOverflow(allocSize: number) {
                abort("Stack overflow! Attempted to allocate " + allocSize + " bytes on the stack, but stack has only " + (STACK_MAX - stackSave() + allocSize) + " bytes available!")
            }

            function abortOnCannotGrowMemory() {
                abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")
            }

            function enlargeMemory() {
                abortOnCannotGrowMemory()
            }
            var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;
            var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 545259520;
            if (TOTAL_MEMORY < TOTAL_STACK) err("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");
            assert(typeof Int32Array !== "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, "JS engine does not provide full typed array support");
            if (Module["buffer"]) {
                buffer = Module["buffer"];
                assert(buffer.byteLength === TOTAL_MEMORY, "provided buffer should be " + TOTAL_MEMORY + " bytes, but it is " + buffer.byteLength)
            } else {
                if (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function") {
                    assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
                    Module["wasmMemory"] = new WebAssembly.Memory({
                        "initial": TOTAL_MEMORY / WASM_PAGE_SIZE,
                        "maximum": TOTAL_MEMORY / WASM_PAGE_SIZE
                    });
                    buffer = Module["wasmMemory"].buffer
                } else {
                    buffer = new ArrayBuffer(TOTAL_MEMORY)
                }
                assert(buffer.byteLength === TOTAL_MEMORY);
                Module["buffer"] = buffer
            }
            updateGlobalBufferViews();

            function getTotalMemory() {
                return TOTAL_MEMORY
            }
            // @ts-ignore
            HEAP32[0] = 1668509029;
            // @ts-ignore
            HEAP16[1] = 25459;
            // @ts-ignore
            if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw "Runtime error: expected the system to be little-endian!";

            function callRuntimeCallbacks(callbacks: Array<any>) {
                while (callbacks.length > 0) {
                    var callback = callbacks.shift();
                    if (typeof callback == "function") {
                        callback();
                        continue
                    }
                    var func = callback.func;
                    if (typeof func === "number") {
                        if (callback.arg === undefined) {
                            Module["dynCall_v"](func)
                        } else {
                            Module["dynCall_vi"](func, callback.arg)
                        }
                    } else {
                        func(callback.arg === undefined ? null : callback.arg)
                    }
                }
            }
            var __ATPRERUN__: any[] = [];
            var __ATINIT__: any[] = [];
            var __ATMAIN__: any[] = [];
            var __ATPOSTRUN__: any[] = [];
            var runtimeInitialized = false;
            var runtimeExited = false;

            function preRun() {
                if (Module["preRun"]) {
                    if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
                    while (Module["preRun"].length) {
                        addOnPreRun(Module["preRun"].shift())
                    }
                }
                callRuntimeCallbacks(__ATPRERUN__)
            }

            function ensureInitRuntime() {
                checkStackCookie();
                if (runtimeInitialized) return;
                runtimeInitialized = true;
                callRuntimeCallbacks(__ATINIT__)
            }

            function preMain() {
                checkStackCookie();
                callRuntimeCallbacks(__ATMAIN__)
            }

            function postRun() {
                checkStackCookie();
                if (Module["postRun"]) {
                    if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
                    while (Module["postRun"].length) {
                        addOnPostRun(Module["postRun"].shift())
                    }
                }
                callRuntimeCallbacks(__ATPOSTRUN__)
            }

            function addOnPreRun(cb: Function) {
                __ATPRERUN__.unshift(cb)
            }

            function addOnPostRun(cb: Function) {
                __ATPOSTRUN__.unshift(cb)
            }
            assert(Math["imul"] && Math["fround"] && Math["clz32"] && Math["trunc"], "this is a legacy browser, build with LEGACY_VM_SUPPORT");
            var Math_abs = Math.abs;
            var Math_ceil = Math.ceil;
            var Math_floor = Math.floor;
            var Math_min = Math.min;
            var runDependencies = 0;
            var runDependencyWatcher: any = null;
            var dependenciesFulfilled: any = null;
            var runDependencyTracking = {};

            function addRunDependency(id: any) {
                runDependencies++;
                if (Module["monitorRunDependencies"]) {
                    Module["monitorRunDependencies"](runDependencies)
                }
                if (id) {
                    // @ts-ignore
                    assert(!runDependencyTracking[id]);
                    // @ts-ignore
                    runDependencyTracking[id] = 1;
                    if (runDependencyWatcher === null && typeof setInterval !== "undefined") {
                        runDependencyWatcher = setInterval((function () {
                            if (ABORT) {
                                clearInterval(runDependencyWatcher);
                                runDependencyWatcher = null;
                                return
                            }
                            var shown = false;
                            for (var dep in runDependencyTracking) {
                                if (!shown) {
                                    shown = true;
                                    err("still waiting on run dependencies:")
                                }
                                err("dependency: " + dep)
                            }
                            if (shown) {
                                err("(end of list)")
                            }
                        }), 1e4)
                    }
                } else {
                    err("warning: run dependency added without ID")
                }
            }

            function removeRunDependency(id: any) {
                runDependencies--;
                if (Module["monitorRunDependencies"]) {
                    Module["monitorRunDependencies"](runDependencies)
                }
                if (id) {
                    // @ts-ignore
                    assert(runDependencyTracking[id]);
                    // @ts-ignore
                    delete runDependencyTracking[id]
                } else {
                    err("warning: run dependency removed without ID")
                }
                if (runDependencies == 0) {
                    if (runDependencyWatcher !== null) {
                        clearInterval(runDependencyWatcher);
                        runDependencyWatcher = null
                    }
                    if (dependenciesFulfilled) {
                        var callback = dependenciesFulfilled;
                        dependenciesFulfilled = null;
                        callback()
                    }
                }
            }
            Module["preloadedImages"] = {};
            Module["preloadedAudios"] = {};
            var FS = {
                error: (function () {
                    abort("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1")
                }),
                init: (function () {
                    FS.error()
                }),
                createDataFile: (function () {
                    FS.error()
                }),
                createPreloadedFile: (function () {
                    FS.error()
                }),
                createLazyFile: (function () {
                    FS.error()
                }),
                open: (function () {
                    FS.error()
                }),
                mkdev: (function () {
                    FS.error()
                }),
                registerDevice: (function () {
                    FS.error()
                }),
                analyzePath: (function () {
                    FS.error()
                }),
                loadFilesFromDB: (function () {
                    FS.error()
                }),
                ErrnoError: function ErrnoError() {
                    FS.error()
                }
            };
            Module["FS_createDataFile"] = FS.createDataFile;
            Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
            var dataURIPrefix = "data:application/octet-stream;base64,";

            function isDataURI(filename: string) {
                // @ts-ignore
                return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0
            }

            /**
             * @type {any}
             */
            var _exports = {};

            function integrateWasmJS() {
                var wasmTextFile = "argon2.wast";
                var wasmBinaryFile = "argon2.wasm";
                var asmjsCodeFile = "argon2.temp.asm.js";
                if (!isDataURI(wasmTextFile)) {
                    wasmTextFile = locateFile(wasmTextFile)
                }
                if (!isDataURI(wasmBinaryFile)) {
                    wasmBinaryFile = locateFile(wasmBinaryFile)
                }
                if (!isDataURI(asmjsCodeFile)) {
                    asmjsCodeFile = locateFile(asmjsCodeFile)
                }
                var wasmPageSize = 64 * 1024;
                /**
                 * @type {WebAssembly.Imports}
                 */
                var info = {
                    "global": null,
                    "env": null,
                    "asm2wasm": asm2wasmImports,
                    "parent": Module
                };
                var exports = null;

                function mergeMemory(newBuffer: ArrayBuffer) {
                    var oldBuffer = Module["buffer"];
                    if (newBuffer.byteLength < oldBuffer.byteLength) {
                        err("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here")
                    }
                    var oldView = new Int8Array(oldBuffer);
                    var newView = new Int8Array(newBuffer);
                    newView.set(oldView);
                    updateGlobalBuffer(newBuffer);
                    updateGlobalBufferViews()
                }

                function fixImports(imports: any) {
                    return imports
                }

                function getBinary() {
                    try {
                        if (Module["wasmBinary"]) {
                            return new Uint8Array(Module["wasmBinary"])
                        }
                        if (Module["readBinary"]) {
                            return Module["readBinary"](wasmBinaryFile)
                        } else {
                            throw "both async and sync fetching of the wasm failed"
                        }
                    } catch (err) {
                        abort(err)
                    }
                }

                function getBinaryPromise() {
                    if (!Module["wasmBinary"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
                        return fetch(wasmBinaryFile, {
                            credentials: "same-origin"
                        }).then((function (response) {
                            if (!response["ok"]) {
                                throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                            }
                            return response["arrayBuffer"]()
                        })).catch((function () {
                            return getBinary()
                        }))
                    }
                    return new Promise((function (resolve, reject) {
                        resolve(getBinary())
                    }))
                }

                function doNativeWasm(global: any, env: any, providedBuffer: ArrayBuffer) {
                    if (typeof WebAssembly !== "object") {
                        abort("No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.");
                        err("no native wasm support detected");
                        return false
                    }
                    if (!(Module["wasmMemory"] instanceof WebAssembly.Memory)) {
                        err("no native wasm Memory in use");
                        return false
                    }
                    env["memory"] = Module["wasmMemory"];
                    // @ts-ignore
                    info["global"] = {
                        "NaN": NaN,
                        "Infinity": Infinity
                    };
                    // @ts-ignore
                    info["global.Math"] = Math;
                    info["env"] = env;

                    function receiveInstance(instance: any, module: any) {
                        exports = instance.exports;
                        _exports = instance.exports;
                        if (exports.memory) mergeMemory(exports.memory);
                        Module["asm"] = exports;
                        Module["usingWasm"] = true;
                        removeRunDependency("wasm-instantiate")
                    }
                    addRunDependency("wasm-instantiate");
                    if (Module["instantiateWasm"]) {
                        try {
                            return Module["instantiateWasm"](info, receiveInstance)
                        } catch (e) {
                            err("Module.instantiateWasm callback failed with error: " + e);
                            return false
                        }
                    }
                    var trueModule = Module;

                    function receiveInstantiatedSource(output: any) {
                        assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
                        trueModule = null;
                        receiveInstance(output["instance"], output["module"])
                    }

                    //function instantiateArrayBuffer(receiver: any) {
                    //    getBinaryPromise().then((function (binary) {
                    //        // @ts-ignore
                    //        return WebAssembly.instantiate(binary, info)
                    //    })).then(receiver).catch((function (reason) {
                    //        err("failed to asynchronously prepare wasm: " + reason);
                    //        abort(reason)
                    //    }))
                    //}

                    function instantiateArrayBuffer(receiver: any) {
                        const module = new WebAssembly.Module(getBinary())
                        const binary = {
                            module: module,
                            // @ts-ignore
                            instance: new WebAssembly.Instance(module, info)
                        }
                        return receiver(binary)
                    }

                    if (!Module["wasmBinary"] && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
                        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {
                            credentials: "same-origin"
                            // @ts-ignore
                        }), info).then(receiveInstantiatedSource).catch((function (reason) {
                            err("wasm streaming compile failed: " + reason);
                            err("falling back to ArrayBuffer instantiation");
                            instantiateArrayBuffer(receiveInstantiatedSource)
                        }))
                    } else {
                        instantiateArrayBuffer(receiveInstantiatedSource)
                    }
                    return {}
                }
                Module["asmPreload"] = Module["asm"];
                var asmjsReallocBuffer = Module["reallocBuffer"];
                var wasmReallocBuffer = (function (size: number) {
                    var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;
                    size = alignUp(size, PAGE_MULTIPLE);
                    var old = Module["buffer"];
                    var oldSize = old.byteLength;
                    if (Module["usingWasm"]) {
                        try {
                            var result = Module["wasmMemory"].grow((size - oldSize) / wasmPageSize);
                            if (result !== (-1 | 0)) {
                                return Module["buffer"] = Module["wasmMemory"].buffer
                            } else {
                                return null
                            }
                        } catch (e) {
                            console.error("Module.reallocBuffer: Attempted to grow from " + oldSize + " bytes to " + size + " bytes, but got error: " + e);
                            return null
                        }
                    }
                });
                Module["reallocBuffer"] = (function (size: number) {
                    if (finalMethod === "asmjs") {
                        return asmjsReallocBuffer(size)
                    } else {
                        return wasmReallocBuffer(size)
                    }
                });
                var finalMethod = "";
                Module["asm"] = (function (global: any, env: any, providedBuffer: ArrayBuffer) {
                    env = fixImports(env);
                    if (!env["table"]) {
                        var TABLE_SIZE = Module["wasmTableSize"];
                        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;
                        var MAX_TABLE_SIZE = Module["wasmMaxTableSize"];
                        if (typeof WebAssembly === "object" && typeof WebAssembly.Table === "function") {
                            if (MAX_TABLE_SIZE !== undefined) {
                                env["table"] = new WebAssembly.Table({
                                    "initial": TABLE_SIZE,
                                    "maximum": MAX_TABLE_SIZE,
                                    "element": "anyfunc"
                                })
                            } else {
                                env["table"] = new WebAssembly.Table({
                                    "initial": TABLE_SIZE,
                                    element: "anyfunc"
                                })
                            }
                        } else {
                            env["table"] = new Array(TABLE_SIZE)
                        }
                        Module["wasmTable"] = env["table"]
                    }
                    if (!env["memoryBase"]) {
                        env["memoryBase"] = Module["STATIC_BASE"]
                    }
                    if (!env["tableBase"]) {
                        env["tableBase"] = 0
                    }
                    var exported;
                    exported = doNativeWasm(global, env, providedBuffer);
                    assert(exported, "no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: http://kripken.github.io/emscripten-site/docs/compiling/WebAssembly.html#binaryen-methods");
                    return exported
                })
            }
            integrateWasmJS();
            STATIC_BASE = GLOBAL_BASE;
            STATICTOP = STATIC_BASE + 3424;
            __ATINIT__.push();
            var STATIC_BUMP = 3424;
            Module["STATIC_BASE"] = STATIC_BASE;
            Module["STATIC_BUMP"] = STATIC_BUMP;
            var tempDoublePtr = STATICTOP;
            STATICTOP += 16;
            assert(tempDoublePtr % 8 == 0);

            function _emscripten_memcpy_big(dest: number, src: number, num: number) {
                HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
                return dest
            }

            function _pthread_join() { }

            function ___setErrNo(value: number) {
                if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value;
                else err("failed to set errno from JS");
                return value
            }
            DYNAMICTOP_PTR = staticAlloc(4);
            STACK_BASE = STACKTOP = alignMemory(STATICTOP);
            STACK_MAX = STACK_BASE + TOTAL_STACK;
            DYNAMIC_BASE = alignMemory(STACK_MAX);
            // @ts-ignore
            HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
            staticSealed = true;
            assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");

            function intArrayFromString(stringy: string, dontAddNull: any, length: number) {
                var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
                var u8array = new Array(len);
                // @ts-ignore
                var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
                if (dontAddNull) u8array.length = numBytesWritten;
                return u8array
            }
            Module["wasmTableSize"] = 0;
            Module["wasmMaxTableSize"] = 0;
            Module.asmGlobalArg = {};
            Module.asmLibraryArg = {
                "enlargeMemory": enlargeMemory,
                "getTotalMemory": getTotalMemory,
                "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
                "abortStackOverflow": abortStackOverflow,
                "___setErrNo": ___setErrNo,
                "_emscripten_memcpy_big": _emscripten_memcpy_big,
                "_pthread_join": _pthread_join,
                "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
                "STACKTOP": STACKTOP,
                "STACK_MAX": STACK_MAX
            };
            var asm = Module["asm"](Module.asmGlobalArg, Module.asmLibraryArg, buffer);
            runtimeInitialized = true;
            // @ts-ignore
            var real__argon2_error_message = _exports["_argon2_error_message"];
            asm["_argon2_error_message"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real__argon2_error_message.apply(null, arguments)
            });
            // @ts-ignore
            var real__argon2_hash = _exports["_argon2_hash"];
            asm["_argon2_hash"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real__argon2_hash.apply(null, arguments)
            });
            // @ts-ignore
            var real__free = _exports["_free"];
            asm["_free"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real__free.apply(null, arguments)
            });
            // @ts-ignore
            var real__malloc = _exports["_malloc"];
            asm["_malloc"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real__malloc.apply(null, arguments)
            });
            // @ts-ignore
            var real__sbrk = _exports["_sbrk"];
            asm["_sbrk"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real__sbrk.apply(null, arguments)
            });
            // @ts-ignore
            var real_establishStackSpace = _exports["establishStackSpace"];
            asm["establishStackSpace"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_establishStackSpace.apply(null, arguments)
            });
            // @ts-ignore
            var real_getTempRet0 = _exports["getTempRet0"];
            asm["getTempRet0"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_getTempRet0.apply(null, arguments)
            });
            // @ts-ignore
            var real_setTempRet0 = _exports["setTempRet0"];
            asm["setTempRet0"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_setTempRet0.apply(null, arguments)
            });
            // @ts-ignore
            var real_setThrew = _exports["setThrew"];
            asm["setThrew"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_setThrew.apply(null, arguments)
            });
            // @ts-ignore
            var real_stackAlloc = _exports["stackAlloc"];
            asm["stackAlloc"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_stackAlloc.apply(null, arguments)
            });
            // @ts-ignore
            var real_stackRestore = _exports["stackRestore"];
            asm["stackRestore"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_stackRestore.apply(null, arguments)
            });
            // @ts-ignore
            var real_stackSave = _exports["stackSave"];
            asm["stackSave"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return real_stackSave.apply(null, arguments)
            });
            Module["asm"] = asm;
            var _argon2_error_message = Module["_argon2_error_message"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["_argon2_error_message"].apply(null, arguments)
            });
            var _argon2_hash = Module["_argon2_hash"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["_argon2_hash"].apply(null, arguments)
            });
            var _free = Module["_free"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["_free"].apply(null, arguments)
            });
            var _malloc = Module["_malloc"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");

                return Module["asm"]["_malloc"].apply(null, arguments)
            });
            var _sbrk = Module["_sbrk"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["_sbrk"].apply(null, arguments)
            });
            var establishStackSpace = Module["establishStackSpace"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["establishStackSpace"].apply(null, arguments)
            });
            var getTempRet0 = Module["getTempRet0"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["getTempRet0"].apply(null, arguments)
            });
            var setTempRet0 = Module["setTempRet0"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["setTempRet0"].apply(null, arguments)
            });
            var setThrew = Module["setThrew"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["setThrew"].apply(null, arguments)
            });
            var stackAlloc = Module["stackAlloc"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["stackAlloc"].apply(null, arguments)
            });
            var stackRestore = Module["stackRestore"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["stackRestore"].apply(null, arguments)
            });
            var stackSave = Module["stackSave"] = (function () {
                assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
                assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
                return Module["asm"]["stackSave"].apply(null, arguments)
            });
            Module["asm"] = asm;

            Module["intArrayFromString"] = intArrayFromString;
            if (!Module["intArrayToString"]) Module["intArrayToString"] = (function () {
                abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["ccall"]) Module["ccall"] = (function () {
                abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["cwrap"]) Module["cwrap"] = (function () {
                abort("'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["setValue"]) Module["setValue"] = (function () {
                abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["getValue"]) Module["getValue"] = (function () {
                abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            Module["allocate"] = allocate;
            if (!Module["getMemory"]) Module["getMemory"] = (function () {
                abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            Module["Pointer_stringify"] = Pointer_stringify;
            if (!Module["AsciiToString"]) Module["AsciiToString"] = (function () {
                abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stringToAscii"]) Module["stringToAscii"] = (function () {
                abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["UTF8ArrayToString"]) Module["UTF8ArrayToString"] = (function () {
                abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["UTF8ToString"]) Module["UTF8ToString"] = (function () {
                abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stringToUTF8Array"]) Module["stringToUTF8Array"] = (function () {
                abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stringToUTF8"]) Module["stringToUTF8"] = (function () {
                abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["lengthBytesUTF8"]) Module["lengthBytesUTF8"] = (function () {
                abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["UTF16ToString"]) Module["UTF16ToString"] = (function () {
                abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stringToUTF16"]) Module["stringToUTF16"] = (function () {
                abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["lengthBytesUTF16"]) Module["lengthBytesUTF16"] = (function () {
                abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["UTF32ToString"]) Module["UTF32ToString"] = (function () {
                abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stringToUTF32"]) Module["stringToUTF32"] = (function () {
                abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["lengthBytesUTF32"]) Module["lengthBytesUTF32"] = (function () {
                abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["allocateUTF8"]) Module["allocateUTF8"] = (function () {
                abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stackTrace"]) Module["stackTrace"] = (function () {
                abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addOnPreRun"]) Module["addOnPreRun"] = (function () {
                abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addOnInit"]) Module["addOnInit"] = (function () {
                abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addOnPreMain"]) Module["addOnPreMain"] = (function () {
                abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addOnExit"]) Module["addOnExit"] = (function () {
                abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addOnPostRun"]) Module["addOnPostRun"] = (function () {
                abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["writeStringToMemory"]) Module["writeStringToMemory"] = (function () {
                abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["writeArrayToMemory"]) Module["writeArrayToMemory"] = (function () {
                abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["writeAsciiToMemory"]) Module["writeAsciiToMemory"] = (function () {
                abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addRunDependency"]) Module["addRunDependency"] = (function () {
                abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["removeRunDependency"]) Module["removeRunDependency"] = (function () {
                abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["ENV"]) Module["ENV"] = (function () {
                abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["FS"]) Module["FS"] = (function () {
                abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["FS_createFolder"]) Module["FS_createFolder"] = (function () {
                abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_createPath"]) Module["FS_createPath"] = (function () {
                abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_createDataFile"]) Module["FS_createDataFile"] = (function () {
                abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_createPreloadedFile"]) Module["FS_createPreloadedFile"] = (function () {
                abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_createLazyFile"]) Module["FS_createLazyFile"] = (function () {
                abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_createLink"]) Module["FS_createLink"] = (function () {
                abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_createDevice"]) Module["FS_createDevice"] = (function () {
                abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["FS_unlink"]) Module["FS_unlink"] = (function () {
                abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")
            });
            if (!Module["GL"]) Module["GL"] = (function () {
                abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["staticAlloc"]) Module["staticAlloc"] = (function () {
                abort("'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["dynamicAlloc"]) Module["dynamicAlloc"] = (function () {
                abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["warnOnce"]) Module["warnOnce"] = (function () {
                abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["loadDynamicLibrary"]) Module["loadDynamicLibrary"] = (function () {
                abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["loadWebAssemblyModule"]) Module["loadWebAssemblyModule"] = (function () {
                abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["getLEB"]) Module["getLEB"] = (function () {
                abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["getFunctionTables"]) Module["getFunctionTables"] = (function () {
                abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["alignFunctionTables"]) Module["alignFunctionTables"] = (function () {
                abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["registerFunctions"]) Module["registerFunctions"] = (function () {
                abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["addFunction"]) Module["addFunction"] = (function () {
                abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["removeFunction"]) Module["removeFunction"] = (function () {
                abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["getFuncWrapper"]) Module["getFuncWrapper"] = (function () {
                abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["prettyPrint"]) Module["prettyPrint"] = (function () {
                abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["makeBigInt"]) Module["makeBigInt"] = (function () {
                abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["dynCall"]) Module["dynCall"] = (function () {
                abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["getCompilerSetting"]) Module["getCompilerSetting"] = (function () {
                abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stackSave"]) Module["stackSave"] = (function () {
                abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stackRestore"]) Module["stackRestore"] = (function () {
                abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["stackAlloc"]) Module["stackAlloc"] = (function () {
                abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["establishStackSpace"]) Module["establishStackSpace"] = (function () {
                abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["print"]) Module["print"] = (function () {
                abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            if (!Module["printErr"]) Module["printErr"] = (function () {
                abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
            });
            Module["ALLOC_NORMAL"] = ALLOC_NORMAL;
            if (!Module["ALLOC_STACK"]) Object.defineProperty(Module, "ALLOC_STACK", {
                get: (function () {
                    abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
                })
            });
            if (!Module["ALLOC_STATIC"]) Object.defineProperty(Module, "ALLOC_STATIC", {
                get: (function () {
                    abort("'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
                })
            });
            if (!Module["ALLOC_DYNAMIC"]) Object.defineProperty(Module, "ALLOC_DYNAMIC", {
                get: (function () {
                    abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
                })
            });
            if (!Module["ALLOC_NONE"]) Object.defineProperty(Module, "ALLOC_NONE", {
                get: (function () {
                    abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")
                })
            });
            Module["then"] = (function (func: Function) {
                if (Module["calledRun"]) {
                    func(Module)
                } else {
                    var old = Module["onRuntimeInitialized"];
                    Module["onRuntimeInitialized"] = (function () {
                        if (old) old();
                        func(Module)
                    })
                }
                return Module
            });

            function ExitStatus(status: number) {
                // @ts-ignore
                this.name = "ExitStatus";
                // @ts-ignore
                this.message = "Program terminated with exit(" + status + ")";
                // @ts-ignore
                this.status = status
            }
            ExitStatus.prototype = new Error;
            ExitStatus.prototype.constructor = ExitStatus;
            dependenciesFulfilled = function runCaller() {
                if (!Module["calledRun"]) run();
                if (!Module["calledRun"]) dependenciesFulfilled = runCaller
            };

            function run(args?: any) {
                args = args || Module["arguments"];
                if (runDependencies > 0) {
                    return
                }
                writeStackCookie();
                preRun();
                if (runDependencies > 0) return;
                if (Module["calledRun"]) return;

                function doRun() {
                    if (Module["calledRun"]) return;
                    Module["calledRun"] = true;
                    if (ABORT) return;
                    ensureInitRuntime();
                    preMain();
                    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
                    assert(!Module["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
                    postRun()
                }
                if (Module["setStatus"]) {
                    Module["setStatus"]("Running...");
                    setTimeout((function () {
                        setTimeout((function () {
                            Module["setStatus"]("")
                        }), 1);
                        doRun()
                    }), 1)
                } else {
                    doRun()
                }
                checkStackCookie()
            }
            Module["run"] = run;
            var abortDecorators: any[] = [];

            function abort(what: any) {
                if (Module["onAbort"]) {
                    Module["onAbort"](what)
                }
                if (what !== undefined) {
                    out(what);
                    err(what);
                    what = JSON.stringify(what)
                } else {
                    what = ""
                }
                ABORT = true;
                EXITSTATUS = 1;
                var extra = "";
                var output = "abort(" + what + ") at " + stackTrace() + extra;
                if (abortDecorators) {
                    abortDecorators.forEach((function (decorator) {
                        output = decorator(output, what)
                    }))
                }
                throw output
            }
            Module["abort"] = abort;
            if (Module["preInit"]) {
                if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
                while (Module["preInit"].length > 0) {
                    Module["preInit"].pop()()
                }
            }
            Module["noExitRuntime"] = true;
            run();




            return Module;
        }
    );
})();

/**
 * @type {any}
 */
const Module: any = {};

Module.printErr = console.error;
Module.setStatus = () => { }; //console.log;

const ArgonType = {
    Argon2d:  0,
    Argon2i:  1,
    Argon2id: 2,
    Argon2u:  10
};

type params = {
    /**
     * password string
     */
    pass: string|Uint8Array;
    /**
     * salt string
     */
    salt: string|Uint8Array;
    /**
     * the number of iterations
     * 
     * default 1
     */
    time?: number;
    /**
     * used memory, in KiB
     * 
     * default 1024
     */
    mem?: number;
    /**
     * desired hash length
     * 
     * default 24
     */
    hashLen?: number;
    /**
     * desired parallelism (will be computed in parallel only for  PNaCl)
     * 
     * default 1
     */
    parallelism?: number;
    /**
     * hash type: ArgonType.Argon2d, . Argon2i, .Argon2id or .Argon2u
     * 
     * default Argon2d
     */
    type?: number;
}

/**
* Argon2 hash
* @param {string|Uint8Array} params.pass - password string
* @param {string|Uint8Array} params.salt - salt string
* @param {number} [params.time=1] - the number of iterations
* @param {number} [params.mem=1024] - used memory, in KiB
* @param {number} [params.hashLen=32] - desired hash length
* @param {number} [params.parallelism=1] - desired parallelism (will be computed in parallel only for PNaCl)
* @param {number} [params.type=argon2.types.Argon2d] - hash type: argon2.ArgonType.Argon2d, .Argon2i, .Argon2id or .Argon2u
*
* @example
*  const h = argon2.hash({ pass: 'password', salt: 'somesalt' });
*  console.log(h.hash, h.hashHex, h.encoded);
*/
function _argon2(args: params): {hash: Uint8Array,hashHex:string, encoded:string, message: string, code: number} {
    if (!WebAssembly) {
        throw new Error('Argon2 needs WebAssembly but it is not supported here.');
    }

    if (Module._argon2_hash) {
        try {
            return calcHash(args);
        } catch (e) {
            throw (e);
        }
    } else {
        loadModule(Module);
        try {
            return calcHash(args);
        } catch (e) {
            throw (e);
        }
    }
}

function allocateArray(strOrArr: string | Array<any> | Uint8Array) {
    var arr = strOrArr instanceof Uint8Array || strOrArr instanceof Array ? strOrArr
        : Module.intArrayFromString(strOrArr);
    return Module.allocate(arr, 'i8', Module.ALLOC_NORMAL);
}

function calcHash(arg: params) {
    if (!Module._argon2_hash) {
        throw new Error('Error: _argon2_hash not available');
    }
    var t_cost = arg && arg.time || 1;
    var m_cost = arg && arg.mem || 1024;
    var parallelism = arg && arg.parallelism || 1;
    var pwd = allocateArray(arg && arg.pass || 'password');
    var pwdlen = arg && arg.pass ? arg.pass.length : 8;
    var salt = allocateArray(arg && arg.salt || 'somesalt');
    var saltlen = arg && arg.salt ? arg.salt.length : 8;
    var hash = Module.allocate(new Array(arg && arg.hashLen || 32), 'i8', Module.ALLOC_NORMAL);
    var hashlen = arg && arg.hashLen || 32;
    var encoded = Module.allocate(new Array(512), 'i8', Module.ALLOC_NORMAL);
    var encodedlen = 512;
    var argon2_type = arg && arg.type || 0;
    var version = 0x13;
    var err;
    var out = false;
    try {
        var res = Module._argon2_hash(t_cost, m_cost, parallelism, pwd, pwdlen, salt, saltlen,
            hash, hashlen, encoded, encodedlen,
            argon2_type, version);
    } catch (e) {
        err = e;
    }
    var result;
    if (res === 0 && !err) {
        var hashStr = '';
        var hashArr = new Uint8Array(hashlen);
        for (var i = 0; i < hashlen; i++) {
            var byte = Module.HEAP8[hash + i];
            hashArr[i] = byte;
            hashStr += ('0' + (0xFF & byte).toString(16)).slice(-2);
        }
        var encodedStr = Module.Pointer_stringify(encoded);
        result = { hash: hashArr, hashHex: hashStr, encoded: encodedStr, message: "success", code: res };
    } else {
        try {
            if (!err) {
                err = Module.Pointer_stringify(Module._argon2_error_message(res))
            }
        } catch (e) {
        }
        result = { hash: new Uint8Array(), hashHex: "", encoded:"", message: err, code: res };
    }
    try {
        Module._free(pwd);
        Module._free(salt);
        Module._free(hash);
        Module._free(encoded);
    } catch (e) { }
    if (err) {
        throw result;
    } else {
        return result;
    }
}

function strToUint8Array(str: string): Uint8Array {
    // Check if the browser supports TextDecoder API
    try {
        const encoder = new TextEncoder();

        // Encode the string and return as a Uint8Array
        return encoder.encode(str);
    } catch (e) { }

    // Fallback for older systems without TextDecoder support
    let result = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        const codePoint = str.charCodeAt(i);
        if (codePoint <= 255) {
            result[i] = codePoint;
        } else {
            result.set([codePoint >> 8, codePoint & 0xFF], i * 2);
        }
    }
    return result;
}

function formatMessage(message?: InputData): Uint8Array {
    if (message === undefined) {
        return new Uint8Array(8);
    }

    if (typeof message === 'string') {
        if(message.length != 8){
            while (message.length != 8) {
                message += '\0';
            }
        }
        return strToUint8Array(message);
    }

    if (Buffer.isBuffer(message)) {
        const data = new Uint8Array(message);
        if(data.length != 8){
            const newBuff = Buffer.alloc(8);
            newBuff.set(data);
            return new Uint8Array(newBuff);
        }
        return data;
    }

    if (message instanceof Uint8Array) {
        if(message.length != 8){
            const data = new Uint8Array(8);
            for (let i = 0; i < message.length; i++) {
                data[i] = message[i];
            }
            return data;
        }
        return message as Uint8Array;
    }

    throw new Error('input is invalid type');
}

// Input types
type InputData = string | Uint8Array | Buffer;

// Output formats
type OutputFormat = 'encoded' | 'hex' | 'array' | 'buffer';

function arrayType():OutputFormat{
	if (typeof window !== 'undefined') {
		return "array" as OutputFormat;
	} else {
        return "buffer" as OutputFormat;
	}
};

/**
 * Creates a vary byte Argon2 of the password as either an encoded string, hex string, Uint8Array or Buffer. Accepts strings, Uint8Array or Buffer.
 * 
 * @param {InputData} password - Password to hash
 * @param {InputData} salt Salt for password
 * @param {OutputFormat?} format - Return format as an encoded string, hex string, Uint8Array, Buffer
 * @param {number?} time - computing time of the hash (default `1`)
 * @param {number?} memory - amount of memory to use in KiB (default `1024`)
 * @param {number?} hashLen - output hash length in bytes (default `32`)
 * @param {number?} parallelism - parallelism in the computing of the hash (default `1`)
 * @param {number} type - from {@link ArgonType} (default `Argon2d`)
 * @returns `string|Uint8Array|Buffer`
 */
export function _ARGON2(password: InputData, salt: InputData, format: OutputFormat = arrayType(), time:number = 1, memory:number = 1024, hashLen:number = 32, parallelism:number = 1, type:number = ArgonType.Argon2d){
    password = formatMessage(password);
    salt = formatMessage(salt);
    const hash = _argon2({
        pass: password,
        salt: salt,
        time: time,
        mem: memory,
        hashLen: hashLen,
        parallelism: parallelism,
        type: type
    });
    if(format == "array"){
        return hash.hash;
    } else if(format == 'buffer'){
        return Buffer.from(hash.hash);
    } else if(format == "encoded"){
        return hash.encoded;
    } else {
        // hex
        return hash.hashHex;
    }
}

/**
 * Creates a vary byte Argon2d of the password as either an encoded string, hex string, Uint8Array or Buffer. Accepts strings, Uint8Array or Buffer.
 * 
 * @param {InputData} password - Password to hash
 * @param {InputData} salt Salt for password
 * @param {OutputFormat?} format - Return format as an encoded string, hex string, Uint8Array, Buffer
 * @param {number?} time - computing time of the hash (default `1`)
 * @param {number?} memory - amount of memory to use in KiB (default `1024`)
 * @param {number?} hashLen - output hash length in bytes (default `32`)
 * @param {number?} parallelism - parallelism in the computing of the hash (default `1`)
 * @returns `string|Uint8Array|Buffer`
 */
export function ARGON2D(password: InputData, salt: InputData, format: OutputFormat = arrayType(), time:number = 1, memory:number = 1024, hashLen:number = 32, parallelism:number = 1){
    return _ARGON2(password, salt, format, time,memory, hashLen, parallelism, ArgonType.Argon2d);
}

/**
 * Creates a vary byte Argon2i of the password as either an encoded string, hex string, Uint8Array or Buffer. Accepts strings, Uint8Array or Buffer.
 * 
 * @param {InputData} password - Password to hash
 * @param {InputData} salt Salt for password
 * @param {OutputFormat?} format - Return format as an encoded string, hex string, Uint8Array, Buffer
 * @param {number?} time - computing time of the hash (default `1`)
 * @param {number?} memory - amount of memory to use in KiB (default `1024`)
 * @param {number?} hashLen - output hash length in bytes (default `32`)
 * @param {number?} parallelism - parallelism in the computing of the hash (default `1`)
 * @returns `string|Uint8Array|Buffer`
 */
export function ARGON2I(password: InputData, salt: InputData, format: OutputFormat = arrayType(), time:number = 1, memory:number = 1024, hashLen:number = 32, parallelism:number = 1){
    return _ARGON2(password, salt, format, time,memory, hashLen, parallelism, ArgonType.Argon2i);
}

/**
 * Creates a vary byte Argon2id of the password as either an encoded string, hex string, Uint8Array or Buffer. Accepts strings, Uint8Array or Buffer.
 * 
 * @param {InputData} password - Password to hash
 * @param {InputData} salt Salt for password
 * @param {OutputFormat?} format - Return format as an encoded string, hex string, Uint8Array, Buffer
 * @param {number?} time - computing time of the hash (default `1`)
 * @param {number?} memory - amount of memory to use in KiB (default `1024`)
 * @param {number?} hashLen - output hash length in bytes (default `32`)
 * @param {number?} parallelism - parallelism in the computing of the hash (default `1`)
 * @returns `string|Uint8Array|Buffer`
 */
export function ARGON2ID(password: InputData, salt: InputData, format: OutputFormat = arrayType(), time:number = 1, memory:number = 1024, hashLen:number = 32, parallelism:number = 1){
    return _ARGON2(password, salt, format, time,memory, hashLen, parallelism, ArgonType.Argon2id);
}

/**
 * Creates a vary byte Argon2u of the password as either an encoded string, hex string, Uint8Array or Buffer. Accepts strings, Uint8Array or Buffer.
 * 
 * @param {InputData} password - Password to hash
 * @param {InputData} salt Salt for password
 * @param {OutputFormat?} format - Return format as an encoded string, hex string, Uint8Array, Buffer
 * @param {number?} time - computing time of the hash (default `1`)
 * @param {number?} memory - amount of memory to use in KiB (default `1024`)
 * @param {number?} hashLen - output hash length in bytes (default `32`)
 * @param {number?} parallelism - parallelism in the computing of the hash (default `1`)
 * @returns `string|Uint8Array|Buffer`
 */
export function ARGON2U(password: InputData, salt: InputData, format: OutputFormat = arrayType(), time:number = 1, memory:number = 1024, hashLen:number = 32, parallelism:number = 1){
    return _ARGON2(password, salt, format, time,memory, hashLen, parallelism, ArgonType.Argon2u);
}

/**
 * Static class of all Argon2 functions and classes
 */
export class ARGON2{
    static ARGON2 = _ARGON2;

    static ARGON2D  = ARGON2D;
    static ARGON2I  = ARGON2I;
    static ARGON2ID = ARGON2ID;
    static ARGON2U  = ARGON2U;
    /**
     * List of all functions in class
     */
    static get FUNCTION_LIST() {
        return [
            "ARGON2",
            "ARGON2D",
            "ARGON2I",
            "ARGON2ID",
            "ARGON2U"
        ]
    }
}